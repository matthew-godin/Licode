import { create_hash as createHash, digest_hash as digestHash, update_hash as updateHash, } from "./wasm.js";
import * as hex from "../../encoding/hex.ts";
import * as base64 from "../../encoding/base64.ts";
export class Hash {
    #hash;
    #digested;
    constructor(algorithm) {
        this.#hash = createHash(algorithm);
        this.#digested = false;
    }
    update(message) {
        let view;
        if (message instanceof Uint8Array) {
            view = message;
        }
        else if (typeof message === "string") {
            view = new TextEncoder().encode(message);
        }
        else if (ArrayBuffer.isView(message)) {
            view = new Uint8Array(message.buffer, message.byteOffset, message.byteLength);
        }
        else if (message instanceof ArrayBuffer) {
            view = new Uint8Array(message);
        }
        else {
            throw new Error("hash: `data` is invalid type");
        }
        const chunkSize = 65_536;
        for (let offset = 0; offset < view.byteLength; offset += chunkSize) {
            updateHash(this.#hash, new Uint8Array(view.buffer, view.byteOffset + offset, Math.min(chunkSize, view.byteLength - offset)));
        }
        return this;
    }
    digest() {
        if (this.#digested)
            throw new Error("hash: already digested");
        this.#digested = true;
        return digestHash(this.#hash);
    }
    toString(format = "hex") {
        const finalized = new Uint8Array(this.digest());
        switch (format) {
            case "hex":
                return new TextDecoder().decode(hex.encode(finalized));
            case "base64":
                return base64.encode(finalized);
            default:
                throw new Error("hash: invalid format");
        }
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaGFzaC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImhhc2gudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBRUEsT0FBTyxFQUNMLFdBQVcsSUFBSSxVQUFVLEVBRXpCLFdBQVcsSUFBSSxVQUFVLEVBQ3pCLFdBQVcsSUFBSSxVQUFVLEdBQzFCLE1BQU0sV0FBVyxDQUFDO0FBRW5CLE9BQU8sS0FBSyxHQUFHLE1BQU0sdUJBQXVCLENBQUM7QUFDN0MsT0FBTyxLQUFLLE1BQU0sTUFBTSwwQkFBMEIsQ0FBQztBQUduRCxNQUFNLE9BQU8sSUFBSTtJQUNmLEtBQUssQ0FBVztJQUNoQixTQUFTLENBQVU7SUFFbkIsWUFBWSxTQUFpQjtRQUMzQixJQUFJLENBQUMsS0FBSyxHQUFHLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQztRQUNuQyxJQUFJLENBQUMsU0FBUyxHQUFHLEtBQUssQ0FBQztJQUN6QixDQUFDO0lBRUQsTUFBTSxDQUFDLE9BQWdCO1FBQ3JCLElBQUksSUFBZ0IsQ0FBQztRQUVyQixJQUFJLE9BQU8sWUFBWSxVQUFVLEVBQUU7WUFDakMsSUFBSSxHQUFHLE9BQU8sQ0FBQztTQUNoQjthQUFNLElBQUksT0FBTyxPQUFPLEtBQUssUUFBUSxFQUFFO1lBQ3RDLElBQUksR0FBRyxJQUFJLFdBQVcsRUFBRSxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUMxQzthQUFNLElBQUksV0FBVyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsRUFBRTtZQUN0QyxJQUFJLEdBQUcsSUFBSSxVQUFVLENBQ25CLE9BQU8sQ0FBQyxNQUFNLEVBQ2QsT0FBTyxDQUFDLFVBQVUsRUFDbEIsT0FBTyxDQUFDLFVBQVUsQ0FDbkIsQ0FBQztTQUNIO2FBQU0sSUFBSSxPQUFPLFlBQVksV0FBVyxFQUFFO1lBQ3pDLElBQUksR0FBRyxJQUFJLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQztTQUNoQzthQUFNO1lBQ0wsTUFBTSxJQUFJLEtBQUssQ0FBQyw4QkFBOEIsQ0FBQyxDQUFDO1NBQ2pEO1FBS0QsTUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDO1FBRXpCLEtBQ0UsSUFBSSxNQUFNLEdBQUcsQ0FBQyxFQUNkLE1BQU0sR0FBRyxJQUFJLENBQUMsVUFBVSxFQUN4QixNQUFNLElBQUksU0FBUyxFQUNuQjtZQUNBLFVBQVUsQ0FDUixJQUFJLENBQUMsS0FBSyxFQUNWLElBQUksVUFBVSxDQUNaLElBQUksQ0FBQyxNQUFNLEVBQ1gsSUFBSSxDQUFDLFVBQVUsR0FBRyxNQUFNLEVBQ3hCLElBQUksQ0FBQyxHQUFHLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxVQUFVLEdBQUcsTUFBTSxDQUFDLENBQzlDLENBQ0YsQ0FBQztTQUNIO1FBRUQsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBR0QsTUFBTTtRQUNKLElBQUksSUFBSSxDQUFDLFNBQVM7WUFBRSxNQUFNLElBQUksS0FBSyxDQUFDLHdCQUF3QixDQUFDLENBQUM7UUFFOUQsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7UUFDdEIsT0FBTyxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFNRCxRQUFRLENBQUMsU0FBdUIsS0FBSztRQUNuQyxNQUFNLFNBQVMsR0FBRyxJQUFJLFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLENBQUMsQ0FBQztRQUVoRCxRQUFRLE1BQU0sRUFBRTtZQUNkLEtBQUssS0FBSztnQkFDUixPQUFPLElBQUksV0FBVyxFQUFFLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxNQUFNLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQztZQUN6RCxLQUFLLFFBQVE7Z0JBQ1gsT0FBTyxNQUFNLENBQUMsTUFBTSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1lBQ2xDO2dCQUNFLE1BQU0sSUFBSSxLQUFLLENBQUMsc0JBQXNCLENBQUMsQ0FBQztTQUMzQztJQUNILENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8vIENvcHlyaWdodCAyMDE4LTIwMjEgdGhlIERlbm8gYXV0aG9ycy4gQWxsIHJpZ2h0cyByZXNlcnZlZC4gTUlUIGxpY2Vuc2UuXG5cbmltcG9ydCB7XG4gIGNyZWF0ZV9oYXNoIGFzIGNyZWF0ZUhhc2gsXG4gIERlbm9IYXNoLFxuICBkaWdlc3RfaGFzaCBhcyBkaWdlc3RIYXNoLFxuICB1cGRhdGVfaGFzaCBhcyB1cGRhdGVIYXNoLFxufSBmcm9tIFwiLi93YXNtLmpzXCI7XG5cbmltcG9ydCAqIGFzIGhleCBmcm9tIFwiLi4vLi4vZW5jb2RpbmcvaGV4LnRzXCI7XG5pbXBvcnQgKiBhcyBiYXNlNjQgZnJvbSBcIi4uLy4uL2VuY29kaW5nL2Jhc2U2NC50c1wiO1xuaW1wb3J0IHR5cGUgeyBIYXNoZXIsIE1lc3NhZ2UsIE91dHB1dEZvcm1hdCB9IGZyb20gXCIuLi9oYXNoZXIudHNcIjtcblxuZXhwb3J0IGNsYXNzIEhhc2ggaW1wbGVtZW50cyBIYXNoZXIge1xuICAjaGFzaDogRGVub0hhc2g7XG4gICNkaWdlc3RlZDogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihhbGdvcml0aG06IHN0cmluZykge1xuICAgIHRoaXMuI2hhc2ggPSBjcmVhdGVIYXNoKGFsZ29yaXRobSk7XG4gICAgdGhpcy4jZGlnZXN0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIHVwZGF0ZShtZXNzYWdlOiBNZXNzYWdlKTogdGhpcyB7XG4gICAgbGV0IHZpZXc6IFVpbnQ4QXJyYXk7XG5cbiAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgIHZpZXcgPSBtZXNzYWdlO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZpZXcgPSBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUobWVzc2FnZSk7XG4gICAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcobWVzc2FnZSkpIHtcbiAgICAgIHZpZXcgPSBuZXcgVWludDhBcnJheShcbiAgICAgICAgbWVzc2FnZS5idWZmZXIsXG4gICAgICAgIG1lc3NhZ2UuYnl0ZU9mZnNldCxcbiAgICAgICAgbWVzc2FnZS5ieXRlTGVuZ3RoLFxuICAgICAgKTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgdmlldyA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJoYXNoOiBgZGF0YWAgaXMgaW52YWxpZCB0eXBlXCIpO1xuICAgIH1cblxuICAgIC8vIE1lc3NhZ2VzIHdpbGwgYmUgc3BsaXQgaW50byBjaHVua3Mgb2YgdGhpcyBzaXplIHRvIGF2b2lkIHVubmVjY2Vzc2FyaWx5XG4gICAgLy8gaW5jcmVhc2luZyB0aGUgc2l6ZSBvZiB0aGUgV0FTTSBoZWFwLlxuXG4gICAgY29uc3QgY2h1bmtTaXplID0gNjVfNTM2O1xuXG4gICAgZm9yIChcbiAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgb2Zmc2V0IDwgdmlldy5ieXRlTGVuZ3RoO1xuICAgICAgb2Zmc2V0ICs9IGNodW5rU2l6ZVxuICAgICkge1xuICAgICAgdXBkYXRlSGFzaChcbiAgICAgICAgdGhpcy4jaGFzaCxcbiAgICAgICAgbmV3IFVpbnQ4QXJyYXkoXG4gICAgICAgICAgdmlldy5idWZmZXIsXG4gICAgICAgICAgdmlldy5ieXRlT2Zmc2V0ICsgb2Zmc2V0LFxuICAgICAgICAgIE1hdGgubWluKGNodW5rU2l6ZSwgdmlldy5ieXRlTGVuZ3RoIC0gb2Zmc2V0KSxcbiAgICAgICAgKSxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKiogUmV0dXJucyBmaW5hbCBoYXNoICovXG4gIGRpZ2VzdCgpOiBBcnJheUJ1ZmZlciB7XG4gICAgaWYgKHRoaXMuI2RpZ2VzdGVkKSB0aHJvdyBuZXcgRXJyb3IoXCJoYXNoOiBhbHJlYWR5IGRpZ2VzdGVkXCIpO1xuXG4gICAgdGhpcy4jZGlnZXN0ZWQgPSB0cnVlO1xuICAgIHJldHVybiBkaWdlc3RIYXNoKHRoaXMuI2hhc2gpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgaGFzaCBhcyBhIHN0cmluZyBvZiBnaXZlbiBmb3JtYXRcbiAgICogQHBhcmFtIGZvcm1hdCBmb3JtYXQgb2Ygb3V0cHV0IHN0cmluZyAoaGV4IG9yIGJhc2U2NCkuIERlZmF1bHQgaXMgaGV4XG4gICAqL1xuICB0b1N0cmluZyhmb3JtYXQ6IE91dHB1dEZvcm1hdCA9IFwiaGV4XCIpOiBzdHJpbmcge1xuICAgIGNvbnN0IGZpbmFsaXplZCA9IG5ldyBVaW50OEFycmF5KHRoaXMuZGlnZXN0KCkpO1xuXG4gICAgc3dpdGNoIChmb3JtYXQpIHtcbiAgICAgIGNhc2UgXCJoZXhcIjpcbiAgICAgICAgcmV0dXJuIG5ldyBUZXh0RGVjb2RlcigpLmRlY29kZShoZXguZW5jb2RlKGZpbmFsaXplZCkpO1xuICAgICAgY2FzZSBcImJhc2U2NFwiOlxuICAgICAgICByZXR1cm4gYmFzZTY0LmVuY29kZShmaW5hbGl6ZWQpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGFzaDogaW52YWxpZCBmb3JtYXRcIik7XG4gICAgfVxuICB9XG59XG4iXX0=